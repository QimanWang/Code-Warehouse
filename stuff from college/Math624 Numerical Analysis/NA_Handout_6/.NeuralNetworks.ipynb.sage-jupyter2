{"type":"settings","kernel":"python2","backend_state":"running","trust":false,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}},"kernel_usage":{"cpu":0,"memory":77676544},"kernel_state":"idle"}
{"type":"cell","id":"a188b9","pos":13,"input":"## The sigmoid function","cell_type":"markdown"}
{"type":"cell","id":"c9cd59","pos":19,"input":"import matplotlib\nimport matplotlib.pyplot as plt","cell_type":"code","exec_count":23}
{"type":"cell","id":"3d4543","pos":27,"input":"xvalsR = redpoints[:,0]\nyvalsR = redpoints[:,1]\nxvalsB = bluepoints[:,0]\nyvalsB = bluepoints[:,1]\nfig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.8])\naxes.plot(xvalsR,yvalsR,'r+',xvalsB,yvalsB,'b.')","output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fb94d161f50>,\n <matplotlib.lines.Line2D at 0x7fb94d067e50>]"},"output_type":"execute_result","exec_count":146},"1":{"data":{"image/png":"b6d68cb1a3f7049c06561fc4ce6caf3cfdc2ccef"},"output_type":"execute_result","exec_count":146}},"cell_type":"code","exec_count":146}
{"type":"cell","id":"9f087d","pos":10,"input":"# can't divide an integer by a list\n2/mylist","output":{"0":{"ename":"TypeError","evalue":"unsupported operand type(s) for /: 'int' and 'list'","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m<ipython-input-17-c421531bf603>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# can't divide an integer by a list\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m \u001b[0;36m2\u001b[0m\u001b[0;34m/\u001b[0m\u001b[0mmylist\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;31mTypeError\u001b[0m: unsupported operand type(s) for /: 'int' and 'list'"]}},"cell_type":"code","exec_count":17}
{"type":"cell","id":"eede21","pos":11,"input":"# you can divide an integer by an np.array.  Be aware that if the np.array is filled with integers, then you'll get integer division\nprint 2/mynplist","output":{"0":{"name":"stdout","output_type":"stream","text":"[2 1 0]\n"}},"cell_type":"code","exec_count":18}
{"type":"cell","id":"6dcc3f","pos":15,"input":"def sigmoid(x):\n    return 1/(1+np.exp(-x))","cell_type":"code","exec_count":20}
{"type":"cell","id":"8426c6","pos":9,"input":"# you can add an integer and an np.array\nprint 1+mynplist","output":{"0":{"name":"stdout","output_type":"stream","text":"[2 3 4]\n"}},"cell_type":"code","exec_count":13}
{"type":"cell","id":"5c2aac","pos":5,"input":"For us, np.arrays will be better than ordinary python lists.  There are numerous reasons for this.  Here are a few things to be aware of regarding lists and np.arrays presented by examples.","cell_type":"markdown"}
{"type":"cell","id":"02e768","pos":3,"input":"Here's how to call the exponential function.","cell_type":"markdown"}
{"type":"file","last_load":1509472660425}
{"type":"cell","id":"064c5d","pos":18,"input":"Lets plot the sigmoid function","cell_type":"markdown"}
{"type":"cell","id":"f6817b","pos":20,"input":"xvals = np.linspace(-20,20,1001)\nyvals = sigmoid(xvals)\nfig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.8])\naxes.plot(xvals,yvals)","output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fb94e48cfd0>]"},"output_type":"execute_result","exec_count":26},"1":{"data":{"image/png":"1b2e9259688771573cea1d85274402c84451c7c2"},"output_type":"execute_result","exec_count":26}},"cell_type":"code","exec_count":26}
{"type":"cell","id":"e23cef","pos":21,"input":"Think of the sigmoid function as capturing the idea of a neuron activating.  A number $x$ can be thought of a signal strength entering a neuron and the value $\\sigma(x)\\in (0,1)$ gives the probability that the neuron fires.","cell_type":"markdown"}
{"type":"cell","id":"e21c0a","pos":32,"input":"### Exercise\nExplain how the network above classifies points as red or blue.","cell_type":"markdown"}
{"type":"cell","id":"96cf7c","pos":22,"input":"## Neural Networks: compositions of sigmoid functions","cell_type":"markdown"}
{"type":"cell","id":"784abd","pos":8,"input":"# can't add an integer and a list\nprint 1+mylist","output":{"0":{"ename":"TypeError","evalue":"unsupported operand type(s) for +: 'int' and 'list'","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m<ipython-input-12-5813b89cdf95>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# can't add an integer and a list\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m \u001b[0;32mprint\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0mmylist\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;31mTypeError\u001b[0m: unsupported operand type(s) for +: 'int' and 'list'"]}},"cell_type":"code","exec_count":12}
{"type":"cell","id":"4f9540","pos":30,"input":"thetavec1=np.array([-300,20,50])\nthetavec2=np.array([80,-20,10])\nthetavec3=np.array([-30,20,20])\nrpts=[] ; bpts=[]\nfor i in range(1000):\n    xvec=np.array([1,randomxpoints[i],randomypoints[i]])\n    a0=sigmoid(np.dot(thetavec1,xvec))\n    a1=sigmoid(np.dot(thetavec2,xvec))\n    a=np.array([1,a0,a1])\n    out=sigmoid(np.dot(thetavec3,a))\n    if(out>.9):\n        rpts.append([randomxpoints[i],randomypoints[i]])\n    else:\n        bpts.append([randomxpoints[i],randomypoints[i]])\nredpoints=np.array(rpts)\nbluepoints=np.array(bpts)","cell_type":"code","exec_count":142}
{"type":"cell","id":"fc5b0d","pos":4,"input":"np.exp(1)","output":{"0":{"data":{"text/plain":"2.7182818284590451"},"output_type":"execute_result","exec_count":2}},"cell_type":"code","exec_count":2}
{"type":"cell","id":"ea0aa8","pos":0,"input":"# Introduction to Neural Networks","cell_type":"markdown"}
{"type":"cell","id":"216caa","pos":31,"input":"xvalsR = redpoints[:,0]\nyvalsR = redpoints[:,1]\nxvalsB = bluepoints[:,0]\nyvalsB = bluepoints[:,1]\nfig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.8])\naxes.plot(xvalsR,yvalsR,'r+',xvalsB,yvalsB,'b.')","output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fb94d437450>,\n <matplotlib.lines.Line2D at 0x7fb94d13d690>]"},"output_type":"execute_result","exec_count":143},"1":{"data":{"image/png":"6b2d3066dfcf90bef4bb6a9dc5ca616604e8f99c"},"output_type":"execute_result","exec_count":143}},"cell_type":"code","exec_count":143}
{"type":"cell","id":"1aa3d5","pos":6,"input":"mylist=[1,2,3]\nmynplist=np.array([1,2,3])","cell_type":"code","exec_count":3}
{"type":"cell","id":"0dd06f","pos":7,"input":"print np.exp(mylist)","output":{"0":{"name":"stdout","output_type":"stream","text":"[  2.71828183   7.3890561   20.08553692]\n"}},"cell_type":"code","exec_count":10}
{"type":"cell","id":"7c00f4","pos":16,"input":"# sigmoid of negative numbers are close to zero\nsigmoid(np.array([-10,-20,-30,-40]))","output":{"0":{"data":{"text/plain":"array([  4.53978687e-05,   2.06115362e-09,   9.35762297e-14,\n         4.24835426e-18])"},"output_type":"execute_result","exec_count":21}},"cell_type":"code","exec_count":21}
{"type":"cell","id":"80fe18","pos":24,"input":"Let's look more closely at the simple picture above with one node and three input edges.  We'll fix some weights $\\theta_0=-400$, $\\theta_1=20$, and $\\theta_2=50$.  We'll assume that $x_0=1$ and we'll look at a bunch of random points $x_1, x_2$ in the rectangle $[0,10]\\times [0,10]$.  If the neuron fires for those values, we'll plot the point red and if the neuron doesn't fire, we'll plot the point blue.  Let's set the firing threshold to be $0.9$.","cell_type":"markdown"}
{"type":"cell","id":"93cfde","pos":28,"input":"### Exercise\nExplain how the network above classifies points as red if they lie above a certain line or blue if they lie below that line.","cell_type":"markdown"}
{"type":"cell","id":"84a5bc","pos":29,"input":"Here's a picture of a more sophisticated network and a picture of how it classifies some random points.\n\n<img src=\"./nn3.png\" />\n","cell_type":"markdown"}
{"type":"cell","id":"74080d","pos":25,"input":"randomxpoints=10*np.random.rand(800)\nrandomypoints=10*np.random.rand(800)","cell_type":"code","exec_count":144}
{"type":"cell","id":"d8f1fa","pos":14,"input":"We now define a function $\\sigma:\\mathbb{R}\\to \\mathbb{R}$ by\n\n$$\\sigma(x)=\\frac{1}{1+\\exp(-x)}$$\n\nI'm denoting this function by the greek letter sigma, but this function is called <em>sigmoid</em> function.","cell_type":"markdown"}
{"type":"cell","id":"064e17","pos":23,"input":"Now, we will consider certain compositions of sigmoid functions.  It will be convenient to have a visual language for these compositions, rather than writing formulas.  The visual language will be a directed graph with nodes and edges.   The nodes represent the sigmoid function, the edges are labelled by real numbers called <em>weights</em>, and open initial edges represent an input for a real number.  Multiple edges coming into a node are summed before applying the sigmoid function.  Here's a picture:\n\n<img src=\"./nn2.png\" />\n\nA more complicated picture like this\n\n<img src=\"./nn1.png\" />\n\nrepresents either\n<ul>\n    <li>a single function $\\mathbb{R}^3 \\to \\mathbb{R}$, if the edges are labelled by weights</li>\n    <li>a set of functions $\\mathbb{R}^3 \\to \\mathbb{R}$, if the edges are unlabelled</li>\n</ul>\n","cell_type":"markdown"}
{"type":"cell","id":"1c996f","pos":2,"input":"import numpy as np","cell_type":"code","exec_count":1}
{"type":"cell","id":"ce604f","pos":26,"input":"thetavec=np.array([-8,-1,2])\nrpts=[] ; bpts=[]\nfor i in range(800):\n    xvec=np.array([1,randomxpoints[i],randomypoints[i]])\n    xdottheta=np.dot(thetavec,xvec)\n    if(sigmoid(xdottheta)>.9):\n        rpts.append([randomxpoints[i],randomypoints[i]])\n    else:\n        bpts.append([randomxpoints[i],randomypoints[i]])\nredpoints=np.array(rpts)\nbluepoints=np.array(bpts)","cell_type":"code","exec_count":145}
{"type":"cell","id":"be811d","pos":17,"input":"# sigmoid of positive numbers are close to one\nsigmoid(np.array([10,20,30,40]))","output":{"0":{"data":{"text/plain":"array([ 0.9999546,  1.       ,  1.       ,  1.       ])"},"output_type":"execute_result","exec_count":22}},"cell_type":"code","exec_count":22}
{"type":"cell","id":"b994ee","pos":12,"input":"# you can divide a float by an np.array.  Here, the integers in the np.array are converted to floats and division is division of floating point numbers\nprint 2.0/mynplist","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 2.          1.          0.66666667]\n"}},"cell_type":"code","exec_count":19}
{"type":"cell","id":"7e21b6","pos":1,"input":"We will definitely need to deal with arrays and other numerical functions, so import numpy.","cell_type":"markdown"}