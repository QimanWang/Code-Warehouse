{"type":"settings","kernel":"python2","backend_state":"running","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}},"kernel_state":"idle"}
{"type":"cell","id":"61dace","pos":32,"input":"Here we consider a function $g:\\mathbb{R}^2 \\to \\mathbb{R}$ defined by $g(x_0,x_1)=3(x_0-2)^2+(x_1-1)^2$.  We define $g$ as a function of $x$, where $x$ should be a list $[x_0,x_1].$","cell_type":"markdown"}
{"type":"cell","id":"2edd95","pos":43,"input":"","cell_type":"code","exec_count":0}
{"type":"cell","id":"4c5be3","pos":17,"input":"x = np.linspace(0,3,7) # make an array of 7 evenly spaced numbers between 0 and 5\nprint x","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0.   0.5  1.   1.5  2.   2.5  3. ]\n"}},"cell_type":"code","exec_count":6}
{"type":"cell","id":"aec30f","pos":22,"input":"fig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7])\naxes.plot(x,y, label=r'$y = x^2$')\naxes.legend(loc=2); # upper left corner;","output":{"0":{"data":{"image/png":"c2b61baffea00c8a8180d2597a5fb4c69fdbf3f9"},"output_type":"execute_result","exec_count":9}},"cell_type":"code","exec_count":9}
{"type":"cell","id":"4739a2","pos":38,"input":"plt.figure()\nplt.contour(X0,X1,Z,50) # this plots level sets\nplt.plot(x0_coordlist,x1_coordlist,c=\"r\"); # here is the gradient path","output":{"0":{"data":{"image/png":"b070a8b15e5798f48d416df25a7845d62f922f1c"},"output_type":"execute_result","exec_count":20}},"cell_type":"code","exec_count":20}
{"type":"cell","id":"722c92","pos":29,"input":"Let's take a closer look:","cell_type":"markdown"}
{"type":"cell","id":"0273ac","pos":28,"input":"fig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7]) # left, bottom, width, height (range 0 to 1)\naxes.plot(x,y, 'g', label=r'$y = x^4-3x^3+2$') # g for green\naxes.scatter(x_list,y_list,c=\"r\")\naxes.plot(x_list,y_list,c=\"r\",label='gradient descent steps')\naxes.legend(loc=2); # upper left corner\naxes.set_xlabel('$x$')\naxes.set_ylabel('$y$') ;","output":{"0":{"data":{"image/png":"2816c912bf674f071451e15cec112962c1d6f6cf"},"output_type":"execute_result","exec_count":13}},"cell_type":"code","exec_count":13}
{"type":"cell","id":"c519d2","pos":15,"input":"f(2)","output":{"0":{"data":{"text/plain":"-6"},"output_type":"execute_result","exec_count":5}},"cell_type":"code","exec_count":5}
{"type":"cell","id":"b6f0f1","pos":30,"input":"xzoom = np.linspace(0,2.5,100)\nyzoom=f(xzoom)\n\nmatplotlib.rcParams.update({'font.size': 12, 'text.usetex': True})\n\nfig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7]) # left, bottom, width, height (range 0 to 1)\naxes.plot(xzoom,yzoom, 'g', label=r'$y = x^4-3x^3+2$') # g for green\naxes.scatter(x_list[8:],y_list[8:],c=\"r\")\naxes.plot(x_list[8:],y_list[8:],c=\"r\",label='gradient descent steps')\naxes.legend(loc=1); # upper right corner\naxes.set_xlabel('$x$')\naxes.set_ylabel('$y$') ;","output":{"0":{"data":{"image/png":"c7219b02dd022d1aca384c7fcf1261a698f8991e"},"output_type":"execute_result","exec_count":14}},"cell_type":"code","exec_count":14}
{"type":"cell","id":"ea2d4a","pos":39,"input":"from mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib import cm\n\nfig = plt.figure(figsize=(10,10))\n#ax = fig.add_subplot(1,1,1, projection='3d')\n#ax=gca(projection='3d')\n#fig = plt.figure()\nax = fig.gca (projection='3d')\nax.plot_wireframe(X0, X1, Z, rcount=10, ccount=10);\nax.plot_surface(X0, X1, Z, alpha=0.25)\nax.plot(x0_coordlist,x1_coordlist,z_coordlist,c=\"r\")\nax.view_init(20, -80)","output":{"0":{"ename":"AttributeError","evalue":"Unknown property rcount","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)","\u001b[0;32m<ipython-input-21-5a80cd1e3e2b>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[0;31m#fig = plt.figure()\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[0max\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfig\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgca\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mprojection\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'3d'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 9\u001b[0;31m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot_wireframe\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mZ\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrcount\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m10\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mccount\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m10\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     10\u001b[0m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot_surface\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mZ\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.25\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx0_coordlist\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mx1_coordlist\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mz_coordlist\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mc\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"r\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.0/local/lib/python2.7/site-packages/mpl_toolkits/mplot3d/axes3d.pyc\u001b[0m in \u001b[0;36mplot_wireframe\u001b[0;34m(self, X, Y, Z, *args, **kwargs)\u001b[0m\n\u001b[1;32m   1803\u001b[0m                   zip(txlines, tylines, tzlines)]\n\u001b[1;32m   1804\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1805\u001b[0;31m         \u001b[0mlinec\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mart3d\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mLine3DCollection\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlines\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1806\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd_collection\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlinec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1807\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mauto_scale_xyz\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mY\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mZ\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhad_data\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.0/local/lib/python2.7/site-packages/mpl_toolkits/mplot3d/art3d.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, segments, *args, **kwargs)\u001b[0m\n\u001b[1;32m    207\u001b[0m         \u001b[0mKeyword\u001b[0m \u001b[0marguments\u001b[0m \u001b[0mare\u001b[0m \u001b[0mpassed\u001b[0m \u001b[0monto\u001b[0m \u001b[0;34m:\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m`\u001b[0m\u001b[0;34m~\u001b[0m\u001b[0mmatplotlib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcollections\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mLineCollection\u001b[0m\u001b[0;34m`\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    208\u001b[0m         '''\n\u001b[0;32m--> 209\u001b[0;31m         \u001b[0mLineCollection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msegments\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    210\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    211\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mset_sort_zpos\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mval\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.0/local/lib/python2.7/site-packages/matplotlib/collections.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, segments, linewidths, colors, antialiaseds, linestyles, offsets, transOffset, norm, cmap, pickradius, zorder, facecolors, **kwargs)\u001b[0m\n\u001b[1;32m   1145\u001b[0m             \u001b[0mpickradius\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mpickradius\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1146\u001b[0m             \u001b[0mzorder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mzorder\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1147\u001b[0;31m             **kwargs)\n\u001b[0m\u001b[1;32m   1148\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1149\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mset_segments\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msegments\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.0/local/lib/python2.7/site-packages/matplotlib/collections.pyc\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, edgecolors, facecolors, linewidths, linestyles, antialiaseds, offsets, transOffset, norm, cmap, pickradius, hatch, urls, offset_position, zorder, **kwargs)\u001b[0m\n\u001b[1;32m    137\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    138\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_path_effects\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 139\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    140\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_paths\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    141\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/sage/sage-8.0/local/lib/python2.7/site-packages/matplotlib/artist.pyc\u001b[0m in \u001b[0;36mupdate\u001b[0;34m(self, props)\u001b[0m\n\u001b[1;32m    854\u001b[0m                 \u001b[0mfunc\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'set_'\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mk\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    855\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0mfunc\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0mNone\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0msix\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcallable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 856\u001b[0;31m                     \u001b[0;32mraise\u001b[0m \u001b[0mAttributeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Unknown property %s'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mk\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    857\u001b[0m                 \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    858\u001b[0m             \u001b[0mchanged\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mAttributeError\u001b[0m: Unknown property rcount"]},"1":{"data":{"image/png":"044cc9efcbc9cf444c3bfeab827a20e0397f839f"},"output_type":"execute_result","exec_count":21}},"cell_type":"code","exec_count":21,"collapsed":true}
{"type":"cell","id":"d57ec8","pos":2,"input":"To explain how gradient descent works and visualize the algorithm geometrically, it will help to recall a bit about gradients.","cell_type":"markdown"}
{"type":"cell","id":"7477cf","pos":23,"input":"To get a better picture, we'll use a lot more points.","cell_type":"markdown"}
{"type":"cell","id":"aa717b","pos":40,"input":"# Homework\n\nSuppose that you have data consisting of points in the $x$-$y$ plane\n\n$$(x_0,y_0),(x_1,y_1),\\ldots, (x_N,y_N)$$\n\nand you'd like to find a degree $d$ polynomial $p(x)=a_0 +a_1 x +a_2 x^2 + \\cdots + a_d x^d$ that best fits the data.\n\nOne way to proceed is to think of the coefficients $a_0, \\ldots, a_d$ of the polynomial as variables and to minimize the function \n\n$$C(a_0, \\ldots, a_d)=\\sum_{i=0}^N (y_i - p(x_i))^2.$$\n\nYour problem: find the best degree $5$ polynomial that fits the data from the file datafile.npy.","cell_type":"markdown"}
{"type":"cell","id":"c11c4a","pos":26,"input":"Now, back to gradient descent.","cell_type":"markdown"}
{"type":"cell","id":"c2c929","pos":18,"input":"y=x**2 # squares every number in the list\nprint(y)","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0.    0.25  1.    2.25  4.    6.25  9.  ]\n"}},"cell_type":"code","exec_count":7}
{"type":"cell","id":"4c90af","pos":41,"input":"# load the data:\ndata=np.load('datafile.npy')\nfig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7]) \naxes.scatter(data[:,0],data[:,1],c=\"r\");","output":{"0":{"data":{"image/png":"56a7701e86743734f5e501f535163cd97b6f8427"},"output_type":"execute_result","exec_count":22}},"cell_type":"code","exec_count":22}
{"type":"cell","id":"18c6d3","pos":25,"input":"fig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7])\naxes.plot(x,y, label=r'$y = x^4 - 3  x^3+2$')\naxes.legend(loc=2); # upper left corner;","output":{"0":{"data":{"image/png":"e6a5ae7c9394d8e7e90e1def3b3fb30a8992b939"},"output_type":"execute_result","exec_count":11}},"cell_type":"code","exec_count":11}
{"type":"cell","id":"826bd8","pos":3,"input":"## A quick review about gradients and two important facts","cell_type":"markdown"}
{"type":"cell","id":"28766d","pos":24,"input":"x = np.linspace(0,6,1001)\ny = f(x)","cell_type":"code","exec_count":10}
{"type":"cell","id":"dbab67","pos":14,"input":"Here's how to evaluate this function at a number, say $2$.","cell_type":"markdown"}
{"type":"cell","id":"b37c52","pos":27,"input":"cur_x = 6 # The algorithm starts at x=6\ngamma = 0.01 # step size multiplier\nprecision = 0.00001\nprevious_step_size = cur_x\n\nx_list = [cur_x]; y_list = [f(cur_x)]\n\ndef df(x):\n    return 4 * x**3 - 9 * x**2\n\nwhile previous_step_size > precision:\n    prev_x = cur_x\n    cur_x += -gamma * df(prev_x)\n    previous_step_size = abs(cur_x - prev_x)\n    x_list.append(cur_x)\n    y_list.append(f(cur_x))\n\nprint \"Local minimum occurs at:\", cur_x\nprint \"Number of steps:\", len(x_list)\nprint \"Minimum value:\", f(cur_x)","output":{"0":{"name":"stdout","output_type":"stream","text":"Local minimum occurs at: 2.24996460743\nNumber of steps: 71\nMinimum value: -6.54296873732\n"}},"cell_type":"code","exec_count":12}
{"type":"cell","id":"a32e6c","pos":4,"input":"The gradient of a differentiable function $g:\\mathbb{R}^n \\to \\mathbb{R}$ is defined to be the unique vector field $\\nabla g$ with the property that for each point $x\\in \\mathbb{R}^n$, $$\\langle \\nabla g(x), v\\rangle = D_v g(x).$$\nHere, $\\langle \\, , \\, \\rangle$ denotes the inner product (dot product) of vectors and $D_v g(x)$ denotes the directional derivative of $g$ at the point $x$ in the direction $v$:\n$$D_v g(x)=\\lim_{h \\to 0} \\frac{g(x+hv)-g(x)}{h}.$$\nIn standard coordinates, the gradient can be computed as\n$$\\nabla g(x)=\\left [ \\frac{\\partial g}{\\partial x_0} (x), \\frac{\\partial g}{\\partial x_1} (x), \\ldots, \\frac{\\partial g}{\\partial x_{n-1}} (x) \\right].$$","cell_type":"markdown"}
{"type":"cell","id":"8d8c78","pos":42,"input":"data","output":{"0":{"data":{"text/plain":"array([[  0.        ,   5.85953121],\n       [  0.25      ,  22.88309989],\n       [  0.5       ,  30.38942188],\n       [  0.75      ,  13.21021289],\n       [  1.        ,   0.32720096],\n       [  1.25      ,   3.97301535],\n       [  1.5       ,  -3.90770545],\n       [  1.75      ,   5.3292406 ],\n       [  2.        ,  14.74408003],\n       [  2.25      ,   6.78220144],\n       [  2.5       ,   8.31606066],\n       [  2.75      ,   6.03781717],\n       [  3.        ,  11.00363366],\n       [  3.25      ,  -1.53629526],\n       [  3.5       ,  -0.58868123],\n       [  3.75      ,  -4.30375877],\n       [  4.        ,   9.41031136],\n       [  4.25      ,  18.14232431],\n       [  4.5       ,  54.81734958],\n       [  4.75      ,  92.26249149]])"},"output_type":"execute_result","exec_count":24}},"cell_type":"code","exec_count":24}
{"type":"cell","id":"fb2b6e","pos":31,"input":"## 2 dimensional example","cell_type":"markdown"}
{"type":"cell","id":"738e65","pos":19,"input":"'scatter' plots the points as dots","cell_type":"markdown"}
{"type":"cell","id":"ff0440","pos":12,"input":"Define a function","cell_type":"markdown"}
{"type":"cell","id":"690a16","pos":1,"input":"# From calculation, it is expected that the local minimum occurs at x=9/4\n\ncur_x = 6 # The algorithm starts at x=6\ngamma = 0.01 # step size multiplier\nprecision = 0.00001\nprevious_step_size = cur_x\n\ndef df(x):\n    return 4 * x**3 - 9 * x**2\n\nwhile previous_step_size > precision:\n    prev_x = cur_x\n    cur_x += -gamma * df(prev_x)\n    previous_step_size = abs(cur_x - prev_x)\n\nprint(\"The local minimum occurs at %f\" % cur_x)","output":{"0":{"name":"stdout","output_type":"stream","text":"The local minimum occurs at 2.249965\n"}},"cell_type":"code","exec_count":1}
{"type":"cell","id":"2c0069","pos":0,"input":"# Basic Gradient Descent\n\nGradient descent is an important algorithm for minimizing a function.  Having an algorithm to minimize a function is quite powerful:  you can maximize a function $f$ by minimizing $-f$ and you can solve a system of equations $f_1=k_1, f_2=k_2, \\cdots f_r=k_r$ by minimizing $(f_1-k_1)^2+(f_2-k_2)^2+\\cdots (f_r-k_r)^2$.  \n\nHere's an example, in one variable, implemented in python, from <a href=\"https://en.wikipedia.org/wiki/Gradient_descent#Computational_examples\">https://en.wikipedia.org/wiki/Gradient_descent#Computational_examples</a>.  The program finds the minimum of\n$ f(x) =x^4−3x^3+2. $","cell_type":"markdown"}
{"type":"cell","id":"bff898","pos":20,"input":"fig = plt.figure()\naxes = fig.add_axes([0.1, 0.1, 0.9, 0.7])\naxes.scatter(x,y);","output":{"0":{"name":"stderr","output_type":"stream","text":"/ext/sage/sage-8.0/local/lib/python2.7/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.\n  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')\n"},"1":{"data":{"image/png":"91c7d819db6c86eb915f9a64c03795d9218e738a"},"output_type":"execute_result","exec_count":8}},"cell_type":"code","exec_count":8}
{"type":"cell","id":"7a9fee","pos":37,"input":"x0_coordlist=np.array(x_list)[:,0]\nx1_coordlist=np.array(x_list)[:,1]\nz_coordlist=np.array(z_list)","cell_type":"code","exec_count":19}
{"type":"cell","id":"8c9465","pos":6,"input":"### Perpendicular to level curves\n\nThe level set of $g:\\mathbb{R}^n \\to \\mathbb{R}$ of level $k\\in \\mathbb{R}$ is defined to be the set\n\n$$g^{-1}(k)=\\{(x_0,x_1,  \\ldots, x_{n-1})\\in \\mathbb{R}^n: g(x_0,x_1,  \\ldots, x_{n-1})=k\\}$$\n\nIf $:\\alpha: t\\mapsto (x_0(t),x_1(t),  \\ldots, x_{n-1}(t))$ is a curve in a level set of $g$, then the the function $\\mathbb{R} \\overset{\\alpha}{\\to} \\mathbb{R}^n \\overset{g}{\\to} \\mathbb{R}$ is constant and hence has zero derivative.  Keeping the multivariable chain rule in mind, we have\n\n$$Dg \\circ d\\alpha = 0 \\Longleftrightarrow \\begin{bmatrix} \\frac{\\partial g}{\\partial x_0} (x)& \\frac{\\partial g}{\\partial x_1} (x)& \\ldots & \\frac{\\partial g}{\\partial x_{n-1}} (x) \\end{bmatrix} \\begin{bmatrix} x_0'(t) \\\\ x_1'(t) \\\\ \\vdots \\\\ x_{n-1}'(t)\\end{bmatrix} = 0.$$\n\nIn other words, the gradient $\\nabla g(x)$ is perpendicular to the level sets of $g$.\n\n","cell_type":"markdown"}
{"type":"cell","id":"c9963f","pos":11,"input":"%matplotlib inline","cell_type":"code","exec_count":3}
{"type":"cell","id":"24ae04","pos":7,"input":"Now, let's do some programming.","cell_type":"markdown"}
{"type":"cell","id":"20ecb5","pos":21,"input":"and 'plot' connects the dots with straight lines.","cell_type":"markdown"}
{"type":"cell","id":"8981c4","pos":13,"input":"def f(x):\n    return  x**4 - 3 * x**3+2","cell_type":"code","exec_count":4}
{"type":"cell","id":"504ba1","pos":8,"input":"## Import modules","cell_type":"markdown"}
{"type":"cell","id":"138dd9","pos":34,"input":"def grad_g(x):\n    return np.array([6*(x[0]-2), 2.0*(x[1]-1)])","cell_type":"code","exec_count":16}
{"type":"cell","id":"7e0a62","pos":5,"input":"### Steepest Descent\n\nRecall that $\\langle v,w \\rangle=\\|v\\|w\\| \\cos(\\theta)$ where $\\theta$ is the angle between the vectors $v$ and $w$.  Therefore, if $v$ is a unit vector, \n\n$$D_v g(x)=\\langle \\nabla g(x), v\\rangle =\\|\\nabla g(x)\\| \\cos(\\theta)$$\n\nis maximized when $v$ points in the direction of the gradient $\\nabla g(x)$ and minimized when $v$ points in the direction $-\\nabla g(x)$.\n\n<strong>Conclusion</strong> $-\\nabla g(x)$ is the direction of steepest descent for the function $g$ at the point $x$.","cell_type":"markdown"}
{"type":"cell","id":"5181a7","pos":36,"input":"x0 = np.linspace(-1,6,100)\nx1 = np.linspace(-2,5,100)\nX0, X1 = np.meshgrid(x0,x1)\nZ=g([X0,X1])","cell_type":"code","exec_count":18}
{"type":"cell","id":"c7f5bc","pos":16,"input":"To plot this function, we make a bunch of (x,y) coordinates on the graph.  Before doing this, let's take a look at ways we can operate on elements in a list.","cell_type":"markdown"}
{"type":"cell","id":"63d24a","pos":10,"input":"The following line is a Jupyter code that tells matplotlib to display graphics inline within the jupyter notbook","cell_type":"markdown"}
{"type":"cell","id":"aac054","pos":33,"input":"def g(x):\n    return 3*(x[0]-2)**2+(x[1]-1)**2+5","cell_type":"code","exec_count":15}
{"type":"cell","id":"029eb8","pos":9,"input":"import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt","cell_type":"code","exec_count":2}
{"type":"file","last_load":1505612683669}
{"type":"cell","id":"55c63a","pos":35,"input":"x_old = np.array([0,4])\nh = 0.1 # step size\nprecision = 0.001\n\nx_list = [x_old]\nz_list = [g(x_old)]\n\nx_new = x_old - h * grad_g(x_old)\nx_list.append(x_new)\nz_list.append(g(x_new))\n\nwhile (abs(x_new[0] - x_old[0])+abs(x_new[1] - x_old[1])) > precision:\n    x_old = x_new\n    direction = - grad_g(x_old)\n    x_new = x_old + h * direction\n    x_list.append(x_new)\n    z_list.append(g(x_new))\nprint \"Local minimum occurs at:\", x_new\nprint \"Number of steps:\", len(x_list)\nprint \"minimum value is:\", g(x_new)","output":{"0":{"name":"stdout","output_type":"stream","text":"Local minimum occurs at: [ 2.          1.00371382]\nNumber of steps: 31\nminimum value is: 5.00001379246\n"}},"cell_type":"code","exec_count":17}